---
description: "Complete Cursor 2.2 native tools reference: search, edit, run, and advanced features for agentic workflows"
alwaysApply: false
---

# Cursor 2.2 Tools Mastery

Complete reference for all Cursor IDE tools. Use these tools effectively to accomplish tasks efficiently.

## CRITICAL: Agentic-First Tool Usage

### The Golden Rule: Verify Before You Act

Every action follows this pattern:
1. **CHECK** - What exists? What's the current state?
2. **VERIFY** - What versions? What's available?
3. **ACT** - Make the change using proper tools
4. **VALIDATE** - Did it work? Any errors?

### Pre-Action Verification Protocol

Before ANY significant action:

```
BEFORE CREATING PROJECT:
1. Check if CLI tool exists: Shell(command="which flutter")
2. Check CLI version: Shell(command="flutter --version")
3. Web search for current version: WebSearch(search_term="Flutter stable December 2024")
4. Check if project already exists: LS(target_directory="./")

BEFORE INSTALLING PACKAGES:
1. Check package.json/pubspec.yaml exists: Read(path="package.json")
2. Check if already installed: Read(path="package-lock.json")
3. Verify package name/version: WebSearch(search_term="lodash npm latest version")

BEFORE EDITING CODE:
1. Read the file first: Read(path="src/component.tsx")
2. Understand context and dependencies
3. Check for related files that might need updating
```

### Proactive Web Search Usage

**ALWAYS use WebSearch for:**
- Package versions before installing
- Framework syntax when unsure
- Error messages you encounter
- API documentation verification
- Current best practices

**Search Pattern:**
```
WebSearch(search_term="[package/framework] [specific feature] [current year/month]")
```

Examples:
- `WebSearch(search_term="Next.js 15 App Router server actions December 2024")`
- `WebSearch(search_term="React 19 useFormStatus hook syntax")`
- `WebSearch(search_term="shadcn ui button component installation")`

---

## Search Tools

### `Read`
**Purpose**: Read file contents with line numbers

**When to Use**:
- Examining specific files
- Understanding code structure
- Reviewing implementations
- Checking configurations

**Best Practices**:
- Read whole files unless very large (>1000 lines)
- Use `offset` and `limit` for large files
- Batch multiple file reads in parallel
- Check imports and dependencies

**Example Usage**:
```
Read the main entry point to understand the application structure
→ Read(path="src/index.ts")
```

---

### `LS`
**Purpose**: List directory contents

**When to Use**:
- Exploring project structure
- Finding files in a directory
- Understanding folder organization
- Discovering available modules

**Best Practices**:
- Start at project root for orientation
- Use `ignore_globs` to filter noise (node_modules, etc.)
- Navigate progressively deeper

**Example Usage**:
```
Explore the project structure
→ LS(target_directory=".", ignore_globs=["node_modules", ".git"])
```

---

### `SemanticSearch`
**Purpose**: Semantic search - finds code by meaning, not exact text

**When to Use**:
- Finding implementations by concept
- Locating where behavior is defined
- Understanding how features work
- Exploring unfamiliar codebases

**When NOT to Use**:
- Exact text matches (use `Grep`)
- Simple symbol lookups (use `Grep`)
- Finding files by name (use `Glob`)

**Best Practices**:
- Ask complete questions: "Where is user authentication handled?"
- One question per search (don't combine multiple queries)
- Start broad, then narrow to specific directories
- Use for "how/where/what" questions

**Example Usage**:
```
Find where API routes are defined
→ SemanticSearch(query="Where are the API routes defined?", target_directories=["src/"])
```

---

### `Grep`
**Purpose**: Regex-based text search (powered by ripgrep)

**When to Use**:
- Exact symbol/string searches
- Finding function calls
- Locating imports/exports
- Counting occurrences

**Parameters**:
- `pattern`: Regex pattern to search
- `path`: Directory or file to search
- `type`: File type filter (js, py, rs, go, etc.)
- `glob`: Custom glob pattern
- `-C`, `-A`, `-B`: Context lines
- `output_mode`: "content", "files_with_matches", or "count"

**Best Practices**:
- Escape special regex characters: `functionCall\(`
- Use `output_mode: "files_with_matches"` to find all relevant files
- Add context with `-C 3` to understand surrounding code

**Example Usage**:
```
Find all uses of a specific function
→ Grep(pattern="useAuth\\(", path="src/", type="ts")

Find files containing a pattern
→ Grep(pattern="TODO:", output_mode="files_with_matches")
```

---

### `Glob`
**Purpose**: Find files by name pattern

**When to Use**:
- Locating files by extension
- Finding configuration files
- Discovering test files
- Matching naming conventions

**Best Practices**:
- Patterns auto-prepend `**/` for recursive search
- Use for file discovery, not content search

**Example Usage**:
```
Find all test files
→ Glob(glob_pattern="*.test.ts")

Find configuration files
→ Glob(glob_pattern="*.config.*")
```

---

### `WebSearch`
**Purpose**: Search the internet for real-time information

**When to Use**:
- Current documentation
- Recent solutions
- Security advisories
- Version-specific information

**Best Practices**:
- Include version numbers if relevant
- Add dates for time-sensitive queries
- Use specific keywords

**Proactive Usage**: Don't wait for "Ask" mode - use `WebSearch` proactively in Agent mode when:
- You need current information about libraries or APIs
- Error messages suggest version-specific issues
- User asks about recent features or changes

---

## Browser Tools

Cursor provides built-in browser tools for testing and interacting with web applications.
All browser tools use the `cursor-ide-browser-` prefix.

### `cursor-ide-browser-browser_navigate`
**Purpose**: Navigate to a URL

**When to Use**:
- Testing web application features
- Verifying UI implementations
- Checking deployed changes

### `cursor-ide-browser-browser_snapshot`
**Purpose**: Capture accessibility snapshot of current page

**When to Use**:
- Understanding page structure
- Finding elements to interact with
- Better than screenshots for element identification

**Best Practices**:
- Call snapshot BEFORE clicking/typing to get element refs
- Use returned refs for subsequent interactions

### `cursor-ide-browser-browser_click`
**Purpose**: Click on web page elements

**Parameters**:
- `element`: Human-readable element description
- `ref`: Exact target element reference from snapshot
- `button`: Button to click (defaults to left)
- `doubleClick`: Whether to double-click

### `cursor-ide-browser-browser_type`
**Purpose**: Type text into editable elements

**Parameters**:
- `element`: Human-readable element description
- `ref`: Exact target element reference from snapshot
- `text`: Text to type
- `submit`: Whether to press Enter after typing
- `slowly`: Type one character at a time (for key handlers)

### `cursor-ide-browser-browser_hover`
**Purpose**: Hover over elements (for tooltips, dropdowns)

### `cursor-ide-browser-browser_select_option`
**Purpose**: Select options in dropdowns

### `cursor-ide-browser-browser_press_key`
**Purpose**: Press keyboard keys (e.g., ArrowLeft, Enter, Escape)

### `cursor-ide-browser-browser_wait_for`
**Purpose**: Wait for conditions

**Parameters**:
- `text`: Wait for text to appear
- `textGone`: Wait for text to disappear
- `time`: Wait for specified seconds

### `cursor-ide-browser-browser_navigate_back`
**Purpose**: Go back to previous page

### `cursor-ide-browser-browser_resize`
**Purpose**: Resize browser window for responsive testing

### `cursor-ide-browser-browser_console_messages`
**Purpose**: Get all console messages (errors, warnings, logs)

**When to Use**:
- Debugging JavaScript errors
- Checking for runtime issues
- Verifying console output

### `cursor-ide-browser-browser_network_requests`
**Purpose**: Get all network requests since page load

**When to Use**:
- Debugging API calls
- Verifying request/response data
- Checking for failed requests

### Browser Testing Workflow

```
1. Navigate to the page
   → cursor-ide-browser-browser_navigate(url="http://localhost:3000")

2. Snapshot to get elements
   → cursor-ide-browser-browser_snapshot()

3. Interact using refs from snapshot
   → cursor-ide-browser-browser_click(element="Submit button", ref="btn-submit")

4. Wait for changes if needed
   → cursor-ide-browser-browser_wait_for(text="Success")

5. Snapshot again to verify
   → cursor-ide-browser-browser_snapshot()

6. Check console/network for issues
   → cursor-ide-browser-browser_console_messages()
   → cursor-ide-browser-browser_network_requests()
```

### Proactive Browser Usage

Don't wait for explicit requests - use browser tools proactively when:
- You've implemented a UI feature → test it immediately
- User reports a visual bug → navigate and inspect
- You need to verify API integrations → check network requests
- You're debugging frontend issues → check console messages

---

## Edit Tools

### `StrReplace`
**Purpose**: Exact string replacement in files

**When to Use**:
- Modifying existing code
- Updating function implementations
- Fixing bugs in specific locations
- Renaming with `replace_all: true`

**CRITICAL Rules**:
- `old_string` must be UNIQUE in the file
- Include enough context (3-5 lines before/after)
- Match exact whitespace and indentation
- Preserve original indentation style

**Best Practices**:
- Read the file first to ensure accurate matching
- Include surrounding context for uniqueness
- Use `replace_all: true` for renaming operations
- Make atomic, focused changes

**Example Usage**:
```
Update a function implementation
→ StrReplace(
    path="src/utils.ts",
    old_string="function oldImpl() {\n  return 1;\n}",
    new_string="function oldImpl() {\n  return 2;\n}"
  )
```

---

### `Write`
**Purpose**: Create or overwrite entire files

**When to Use**:
- Creating new files
- Complete file rewrites
- Generating new modules
- Writing configuration files

**Best Practices**:
- ALWAYS read existing files before overwriting
- Prefer `StrReplace` for modifications
- Include all necessary imports
- Follow project conventions

---

### `Delete`
**Purpose**: Remove files from the project

**When to Use**:
- Cleanup during refactoring
- Removing deprecated code
- Deleting generated files

---

### `EditNotebook`
**Purpose**: Edit Jupyter notebook cells

**When to Use**:
- Data science notebooks
- Interactive Python development
- Documentation notebooks

**Best Practices**:
- Set `is_new_cell` correctly
- Use 0-based cell indices
- Provide unique `old_string` for edits

---

## Run Tools

### `Shell`
**Purpose**: Execute shell commands

**When to Use**:
- Building projects
- Running tests
- Installing dependencies
- Executing scripts
- Git operations

**Parameters**:
- `command`: The command to execute
- `description`: Brief description of what the command does
- `is_background`: For long-running processes
- `timeout`: Timeout in milliseconds
- `working_directory`: Directory to run command in

**Best Practices**:
- Use `is_background: true` for long-running processes
- Check existing terminals before starting servers
- Use non-interactive flags (`--yes`, `-y`, etc.)
- Always provide a clear `description`

**Example Usage**:
```
Install dependencies
→ Shell(command="npm install", description="Install dependencies")

Run tests
→ Shell(command="npm test", description="Run tests")

Start dev server in background
→ Shell(command="npm run dev", is_background=true, description="Start dev server")
```

---

### `ReadLints`
**Purpose**: Read linter errors from workspace

**When to Use**:
- After making edits
- Before committing changes
- Debugging type errors
- Checking code quality

**Best Practices**:
- Only call on files you've edited
- Fix errors before proceeding
- Don't call with wide scope

**Example Usage**:
```
Check lints after editing
→ ReadLints(paths=["src/components/Button.tsx"])

---

```

---

## MCP Tools

MCP (Model Context Protocol) tools extend Cursor's capabilities with external services.

### MiniMax MCP Tools
If configured, provides:
- `user-MiniMax-web_search`: Web search with current date context
- `user-MiniMax-understand_image`: Image analysis with VLM

### Context7 MCP Tools
If configured, provides:
- `user-context7-resolve-library-id`: Find library IDs
- `user-context7-query-docs`: Fetch up-to-date documentation

**CRITICAL**: Always check if MCP tools are available before using. Fall back to Cursor's native `WebSearch` if MiniMax MCP is not configured.

---

## Tool Selection Decision Tree

```
Need to find code?
├─ By meaning/concept → SemanticSearch
├─ Exact text/symbol → Grep
└─ By filename → Glob

Need to read?
├─ File contents → Read
├─ Directory structure → LS
└─ Linter errors → ReadLints

Need to edit?
├─ Modify existing → StrReplace
├─ Create new file → Write
├─ Remove file → Delete
└─ Jupyter notebook → EditNotebook

Need to execute?
├─ Shell command → Shell
└─ MCP tool → Use MCP tool directly

Need external info?
├─ Real-time data → WebSearch (Cursor native)
├─ MiniMax search → user-MiniMax-web_search (if configured)
└─ Image analysis → user-MiniMax-understand_image (if configured)

Need to test web UI?
├─ Navigate to page → cursor-ide-browser-browser_navigate
├─ Get page structure → cursor-ide-browser-browser_snapshot
├─ Interact with elements → cursor-ide-browser-browser_click / browser_type
├─ Check for errors → cursor-ide-browser-browser_console_messages
└─ Debug API calls → cursor-ide-browser-browser_network_requests
```

## Parallel vs Sequential Tool Calls

### Use Parallel Calls When:
- Reading multiple independent files
- Searching different directories
- Making independent edits
- Gathering unrelated information

### Use Sequential Calls When:
- Results inform next parameters
- Order matters (create before edit)
- Dependencies between operations
- Validation needed before proceeding

### Example Parallel Pattern:
```
Reading multiple files simultaneously:
→ Read(path="src/index.ts")
→ Read(path="src/config.ts")
→ Read(path="package.json")
[All called in single batch]
```

## Cursor 2.2 Advanced Features

### Debug Mode
- Instruments apps with runtime logs
- Helps reproduce complex bugs
- Works across stacks and languages

### Browser Layout Editor
- Real-time CSS/layout editing
- Component tree visualization
- Integrated with codebase

### Plan Mode + Mermaid
- Visual planning with diagrams
- Send to-dos to new agents
- Structured task management

### Multi-Agent Judging
- Run parallel agents
- Best solution selection
- Automated comparison

### Pinned Chats
- Quick access to important threads
- Persistent conversation references

---

## CRITICAL: What NEVER To Do

### Never Manually Create These Files

These files are generated by CLIs and should NEVER be created manually:

| File Type | Use CLI Instead |
|-----------|----------------|
| `package.json` | `npm init` or `pnpm init` |
| `package-lock.json` | Generated by `npm install` |
| `go.mod` | `go mod init` |
| `Cargo.toml` | `cargo new` or `cargo init` |
| `pubspec.yaml` | `flutter create` |
| `*.xcodeproj/*` | Xcode or `swift package init` |
| `project.pbxproj` | **NEVER TOUCH** - Xcode only |
| `.csproj` | `dotnet new` |
| `pom.xml` | `mvn archetype:generate` |

### Never Skip These Steps

```
❌ DON'T: Create project files manually
✅ DO: Use framework CLI (npx create-next-app, flutter create, cargo new)

❌ DON'T: Assume packages are installed
✅ DO: Run npm install / flutter pub get / cargo build after setup

❌ DON'T: Guess CLI availability
✅ DO: Check with --version first

❌ DON'T: Write code without reading existing files
✅ DO: Always Read before editing

❌ DON'T: Skip dependency installation
✅ DO: npm install, pip install, cargo build after adding deps

❌ DON'T: Forget post-edit verification
✅ DO: Run linters, tests, builds after changes
```

### Always Verify After Actions

```bash
# After creating web project
npm install && npm run dev  # Verify it starts

# After adding shadcn component
npx shadcn@latest add button  # Use CLI, don't copy files!

# After Flutter changes
flutter pub get && flutter analyze

# After Rust changes  
cargo check && cargo clippy

# After Go changes
go build ./... && go vet ./...

# After Python changes
pip install -e . && pytest
```
